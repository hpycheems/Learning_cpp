#include <iostream>
#define MAX_TREE_SIZE 100
/*
*	树的定义：
*		树是n个结点的有限集。n=0时称为空树。在任意一颗非空树中：
*		(1)有且仅有一个特定的称为根的结点；
*		(2)当n>1时，其余结点可分为m个互不相交的有限集T1、T2、...、Tm，
*			其中每一个集合本身又是一颗树，并且称为根的子树。
* 
*		n>0时根结点是唯一的，不可能存在多个根结点
*		m>0时，子树的个数没有限制，但它们一定是互不相交的。
* 
*	结点的分类：
*		结点拥有的子树称为结点的度。度为0的结点称为叶子结点或终端结点；
*		度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。
*		树的度是树内各结点的度的最大值。
* 
*	结点间关系：
*		结点的子树的根称为该结点的孩子，相应地，该节点称为孩子的双亲。同一个双亲的孩子之间相互称兄弟。
*		结点的祖先是从根到该结点所经分支上的所有结点。
*		以某结点为根的子树的任一结点都称为该结点的子孙。
* 
*	树的其他概念：
*		结点的层次从根开始定义起，根为第一层，根的孩子为第二层。
*		其双亲在同一层的结点互为堂兄弟。
*		树中结点的最大层次称为树的深度或高度。
* 
*		如果将树中结点的各子树看成从左至右是有序的，不能交换的，则称该树为有序树，否则称为无序树。
* 
*		森林是m棵互不相交的树的集合。
* 
*		表示法：双亲表示法、孩子表示法、孩子兄弟表示法。
*		双亲表示法：在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。
*					这样的结构可以根据结点的parent指针很容易找到它的双亲结点。
*					如果要知道结点的孩子是什么，需要变量整个结构才行。
*		
*		孩子表示法：把每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表，
*					如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，
*					采用顺序存储结构，存放进一个一维数组中。
* 
*		孩子兄弟表示法：
*			任意一颗树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟存在也是唯一的。
*			因此，分别指向该结点的第一个孩子和此结点的右兄弟。
*====================================================================================================
*		二叉树的定义：
*			二叉树是n个结点的有限集合，该集合或者为空集，或者由一个根结点和两颗互不相交的，
*			分别称为根节点的左子树和右子树的二叉树组成。
* 
*		二叉树特点：
*			每个结点最多有两个子树，所以二叉树中不存在度大于2的结点。
*			左子树和右子树是有顺序的，次序不能任意颠倒。
*			即使树中某个结点只有一棵子树，也要区分它是左子树还是右子树。
*		
*		二叉树的五种形态：
*			1.空二叉树
*			2.只有一个根结点
*			3.根结点只有左子树
*			4.根节点只有右子树
*			5.根结点既有左子树又有右子树
* 
*		特殊二叉树：
*			斜树：所有的结点都只有左子树的二叉树叫做左斜树。
*			所有结点都是只有右子树的二叉树叫做右斜树。
* 
*			满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上，
*			这样的二叉树称为满二叉树。
* 
*			完全二叉树：对一棵具有n个结点的二叉树按层序号，如果编号为i的结点与同样深度
*			的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。
* 
*		二叉树的性质：
*			在二叉树的第i层上至多有 2的i-1次方个结点。
*			深度为k的二叉树至多有2的k次方-1个结点。
*			对任何一棵二叉树T，如果其终端结点数为n0,度为2的结点数为n2则n0 = n2 + 1
*			具有n个结点的完全二叉树的深度为【log2 n】 + 1
*			
*			如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i有：
*				如果i=1，则结点i是二叉树的根，无双亲；如果i>1,则其双亲是结点 i / 2
*				如果2i > n,则结点i无左孩子；否则其左孩子是2i
*				如果2i+1 > n, 则结点i无右孩子；否则其右孩子结点是2i+1
*				
*		二叉树的存储结构：
*			二叉树是一种特殊的树，由于它的特殊性，使得用顺序存储结构也可以实现。
* 
*			二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，
*			也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。
*		
*			二叉链表：二叉树每个结点最多有两个孩子，所以它设计一个数据域和两个指针域。（二叉链表）
*			
*		遍历二叉树：
*			二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得
*			每个结点被访问一次且仅被访问一次。
*		二叉树的遍历方法：
*			前序遍历、中序遍历、后续遍历
*		
*			前序遍历：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树
*			中序遍历：若树为空，则空操作返回，否则从根节点开始（并不是先访问根节点），中序遍历根节点的左子树，
*						然后访问根节点，最后中序遍历右子树。
*			后序遍历：若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。
*			层序遍历：若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下主层遍历，在同一层中，
*						按从左到右的顺序对结点逐个访问。
* 
*		已知前序和后序遍历，是不能确定一棵二叉树的。
* 
*		二叉树的建立：
*			为了能让每个结点确认是否有左右孩子，对它进行扩展。
*			也就是将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如"#"
*			
* 
*		线索二叉树：
*			对于一个有n个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是2n个指针域。
*			而n个结点的二叉树一共有n-1条分支线数，也就是说，其实存在2n-（n-1）=n+1个空指针域。
* 
*			把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，
*			相应的二叉树就成为线索二叉树。
* 
*		其实线索二叉树，等于把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点、查找某个结点都带来了方便。
*		所以我们对二叉树以某种次序遍历其变为线索二叉树的过程称做是线索化。
*		
*		ltag为0时指向该结点的左孩子，为1是指向该结点的前驱
*		rtag为0时指向该结点的右孩子，为1是指向该结点的后继
* 
*		线索化的过程就是在遍历的过程中修改空指针的过程。
* 
* ====================================================================================================
*	树、森林与二叉树的转换：
*		对于树来说，在满足树的条件下可以是任意形状，一个结点可以有任意多个孩子，显然对树
*		的处理要复杂得多。
*		
*		二叉树，尽管它也是树，但是由于每个结点最多只能有左孩子和右孩子，面对的变化就少很多了。
*		如果所有的树都像二叉树一样方便就好了。
* 
*		树的孩子兄弟法可以将一棵树用二叉链表进行存储，所以借助二叉链表，树和二叉树可以相互进行转换。
*		从物理结构来看，它们的二叉链表也是相同的，只是解释不太一样而已。因此，只要设定一定的规则，
*		用二叉树来表示树，甚至表示森林都是可以的，森林与二叉树也可以互相进行转换。
* 
*	树转换为二叉树：
*		步骤如下：
*		1.加线。 在所有兄弟结点之间加一条连线。
*		2.去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。
*		3.层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。注意第一个孩子
*			是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。
* 
*	森林转换为二叉树：
*		森林是由若干棵树组成的，所以完全可以理解为，
*		森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。
*		步骤：
*		1.把每个树转换为二叉树。
*		2.第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为
*			前一棵二叉树的根节点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。
*	
*	二叉树转换为树：
*		步骤：
*		1.加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、。。。、都作为此结点
*		的孩子。将该结点与这些右孩子用线连接起来。
*		2.去线。删除原二叉树中所有结点与其右孩子结点的连线。
*		3.层次调整。使之结构层次分明。
* 
*	二叉树转换为森林：
*		判断一棵二叉树能够转变成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的
*		根节点有没有右孩子，有就是森林，没有就是一棵树。
*		步骤：
*		1.从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右
*			孩子存在，则连线删除。。。。。，直到所有右孩子连线删除为止，的带分离的二叉树。
*		2.再将每棵分离后的二叉树转换为树即可。
*	
*	树与森林的遍历：
*		树的遍历分为两种：
*		1.先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。
*		2.后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。
*		森林的遍历也分为两种：
*		1.前序遍历：先访问森林中第一棵树的根结点，然后依次先根遍历每棵子树，在依次用同样的方式
*			遍历除去第一棵树的剩余树构成的森林。
*		2.后序遍历：先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再
*			依次同样方式遍历除去第一棵树的剩余树构成的森林。
*==============================================================================================
*	哈夫曼树及其应用
*	哈夫曼树定义与原理：
*		从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。
*		树的路径长度就是从树根到每一结点的路径长度之和。
* 
*		如果考虑到带权的结点，结点的带权路径的路径长度为从该结点到树根之间的路径长度与结点上
*		权的乘积。
*		树的带权路径长度为树中所有叶子结点的带权路径长度之和。
* 
*		假设有n个权值{w1,w2,...,wn}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权wk,
*		每个叶子的路径长度为lk，我们我们通常记作，则其中带权路径长度WPL最小的二叉树叫做哈夫曼树。
* 
*		如何构造以及是否是最优：
*		1.先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列。
*		2.取头两个最小权值的结点作为一个新结点N1的两个子结点，注意相对较小的是左孩子。
*		3.将N1替换A与E，插入有序序列中，保持从小到大排列。
*		4.重复步骤2.
*			
*		哈夫曼编码：
*		
*/			


//双亲表示法
typedef int TElemType;
typedef struct PTNode {
	TElemType data;
	int parent;//双亲位置
};
typedef struct PTree{
	PTNode nodes[MAX_TREE_SIZE];
	int r, n; //根的位置和结点数
};

//二叉链表结构
typedef struct BiTNode {
	TElemType data;
	struct BiTNode* lchild, * rchild;
}*BiTree;

//线索二叉树结构实现
typedef enum {Link, Thread} PointerTag;
typedef struct BiThrNode {
	TElemType data;
	struct BiThrNode* lchild, * rchild;
	PointerTag LTag;
	PointerTag RTag;
}BiThrNode, *BiThrTree;

//前序遍历算法
void PreOrderTraverse(BiTree T) {
	if (T == NULL)
		return;
	std::cout << T->data << "\n";
	PreOrderTraverse(T->lchild);
	PreOrderTraverse(T->rchild);
}
//中序遍历
void InOrderTraverse(BiTree T) {
	if (T == nullptr)
		return;
	InOrderTraverse(T->lchild);
	std::cout << T->data << "\n";	
	InOrderTraverse(T->rchild);
}

//后序遍历
void PostOrderTraverse(BiTree T) {
	if (T == nullptr)
		return;

	PostOrderTraverse(T->lchild);
	PostOrderTraverse(T->rchild);
	std::cout << T->data << "\n";
}

//生成二叉树
void CreateBiTree(BiTree *T) {
	TElemType ch;
	std::cin >> ch;
	if (ch == '#')
		*T = NULL;
	else {
		*T = (BiTree)malloc(sizeof(BiTree));
		if (!*T)
			exit(OVERFLOW);
		(*T)->data = ch;
		CreateBiTree(&(*T)->lchild);
		CreateBiTree(&(*T)->rchild);
	}
}

BiThrTree pre; //始终指向刚刚访问过的结点
//中序遍历线索化
void InThreading(BiThrTree p) {
	if (p) {
		InThreading(p->lchild);
		if (!p->lchild) {//没有左孩子
			p->LTag = Thread;
			p->lchild = pre;
		}
		if (!pre->rchild) {//当前节点的前驱 没有右孩子
			pre->RTag = Thread;
			pre->rchild = p;
		}
		pre = p;
		InThreading(p->rchild);
	}
}
//有了线索二叉树后，对它进行遍历时发现，其实就等于操作一个双向链表结构。
void InOrderTraverse_Thr(BiThrTree T) {
	BiThrTree p;
	p = T->lchild;
	while (p != T) {
		while (p->LTag == Link)
			p = p->lchild;
		std::cout << p->data << "\n";
		while (p->RTag == Thread && p->rchild != T) {
			p = p->rchild;
			std::cout << p->data << "\n";
		}
		p = p->rchild;
	}
}

int main(){


	return 0;
}