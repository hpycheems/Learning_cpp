#include <iostream>
#define MAX_TREE_SIZE 100
/*
*	树的定义：
*		树是n个结点的有限集。n=0时称为空树。在任意一颗非空树中：
*		(1)有且仅有一个特定的称为根的结点；
*		(2)当n>1时，其余结点可分为m个互不相交的有限集T1、T2、...、Tm，
*			其中每一个集合本身又是一颗树，并且称为根的子树。
* 
*		n>0时根结点是唯一的，不可能存在多个根结点
*		m>0时，子树的个数没有限制，但它们一定是互不相交的。
* 
*	结点的分类：
*		结点拥有的子树称为结点的度。度为0的结点称为叶子结点或终端结点；
*		度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。
*		树的度是树内各结点的度的最大值。
* 
*	结点间关系：
*		结点的子树的根称为该结点的孩子，相应地，该节点称为孩子的双亲。同一个双亲的孩子之间相互称兄弟。
*		结点的祖先是从根到该结点所经分支上的所有结点。
*		以某结点为根的子树的任一结点都称为该结点的子孙。
* 
*	树的其他概念：
*		结点的层次从根开始定义起，根为第一层，根的孩子为第二层。
*		其双亲在同一层的结点互为堂兄弟。
*		树中结点的最大层次称为树的深度或高度。
* 
*		如果将树中结点的各子树看成从左至右是有序的，不能交换的，则称该树为有序树，否则称为无序树。
* 
*		森林是m棵互不相交的树的集合。
* 
*		表示法：双亲表示法、孩子表示法、孩子兄弟表示法。
*		双亲表示法：在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。
*					这样的结构可以根据结点的parent指针很容易找到它的双亲结点。
*					如果要知道结点的孩子是什么，需要变量整个结构才行。
*		
*		孩子表示法：把每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表，
*					如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，
*					采用顺序存储结构，存放进一个一维数组中。
* 
*		孩子兄弟表示法：
*			任意一颗树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟存在也是唯一的。
*			因此，分别指向该结点的第一个孩子和此结点的右兄弟。
*====================================================================================================
*		二叉树的定义：
*			二叉树是n个结点的有限集合，该集合或者为空集，或者由一个根结点和两颗互不相交的，
*			分别称为根节点的左子树和右子树的二叉树组成。
* 
*		二叉树特点：
*			每个结点最多有两个子树，所以二叉树中不存在度大于2的结点。
*			左子树和右子树是有顺序的，次序不能任意颠倒。
*			即使树中某个结点只有一棵子树，也要区分它是左子树还是右子树。
*		
*		二叉树的五种形态：
*			1.空二叉树
*			2.只有一个根结点
*			3.根结点只有左子树
*			4.根节点只有右子树
*			5.根结点既有左子树又有右子树
* 
*		特殊二叉树：
*			斜树：所有的结点都只有左子树的二叉树叫做左斜树。
*			所有结点都是只有右子树的二叉树叫做右斜树。
* 
*			满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上，
*			这样的二叉树称为满二叉树。
* 
*			完全二叉树：对一棵具有n个结点的二叉树按层序号，如果编号为i的结点与同样深度
*			的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。
* 
*		二叉树的性质：
*			在二叉树的第i层上至多有 2的i-1次方个结点。
*			深度为k的二叉树至多有2的k次方-1个结点。
*			对任何一棵二叉树T，如果其终端结点数为n0,度为2的结点数为n2则n0 = n2 + 1
*			具有n个结点的完全二叉树的深度为【log2 n】 + 1
*			
*			如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i有：
*				如果i=1，则结点i是二叉树的根，无双亲；如果i>1,则其双亲是结点 i / 2
*				如果2i > n,则结点i无左孩子；否则其左孩子是2i
*				如果2i+1 > n, 则结点i无右孩子；否则其右孩子结点是2i+1
*				
*/

//双亲表示法

typedef int TElemType;
typedef struct PTNode {
	TElemType data;
	int parent;//双亲位置
};
typedef struct PTree{
	PTNode nodes[MAX_TREE_SIZE];
	int r, n; //根的位置和结点数
};

int main(){


	return 0;
}