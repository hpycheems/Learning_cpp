#include <iostream>

/*
*	算法：解决特定问题求解步骤的描述，
*		在计算机中表现为指令的有限序列，并且在每条指令表示一个活多个操作。
* 
*	算法的特性：
*		1.输入输出
*		2.有穷性：算法在执行有限的步骤之后，自动结束而不会出现无线循环，
*			并且每一个步骤在可接受的时间内完成。
*		3.确定性：算法的每一步都具有确定的含义，不会出现二义性。
*		4.可行性：算法的每一步都必须可执行的。也就是说，每一步都能够通过执行有限次数完成。
* 
*	算法设计的要求:
*		1.正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、
*			正确反映问题的需求、能够得到问题的正确答案。
*		2.可读性：算法设计的另一目的是为了便于阅读、理解和交流。
*		3.健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常。
*		3.时间效率高和存储量低。
* 
* 
*	算法效率的度量方法：
*		事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对于不同
*			算法编制的程序的运行时间进行比较，从而确定算法效率的高低。
*		
*		事前分析估算法：在计算机程序编制前，依据统计方法对算法进行估算。
*		一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓输入规模是指输入量的多少。
* 
*	函数的渐近增长：给定两个函数f(n)和g(n),如果存在一个整数N,使得对于所有的n>N,f(b)
*		总是比g(n)大，那么，我们说f(n)的渐近增长快于g(n)
* 
*	判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注项的阶数。
*	某个算法，随着n的增大，它会越来越优于另一算法，或者越来越差于另一算法。
* 
*	算法时间复杂度：
*		在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)
*		随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间度量，记
*		作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长
*		率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模
*		n的某个函数。
*	O(1) < O(logn) <  O(n) < O(nlogn) < O(n的平方) < O(n的立方)
* 
*	推导大O阶方法
*	1.用常数1取代运行时间中所有加法常数。
*	2.在修改后的运行次数函数中，只保留最高阶项。
*	3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶
*/

int main() {
	
}